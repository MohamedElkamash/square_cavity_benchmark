#include "udf.hpp"

static dfloat T_cold;
static dfloat T_hot;
static dfloat Ri;

static occa::kernel buoyancyKernel;

void custom_source(nrs_t * nrs, dfloat time, occa::memory o_U, occa::memory o_FU)
{
  auto mesh = nrs->meshV;

  //what momentum equation we want to add gravity to
  int component = 2;
  
  buoyancyKernel(mesh->Nelements, component * nrs->fieldOffset,  nrs->cds->o_S, o_FU);
}


void UDF_LoadKernels(occa::properties & kernelInfo)
{
  //get parameters from par file
  platform->par->extract("casedata", "T_cold", T_cold);
  platform->par->extract("casedata", "T_hot", T_hot);
  platform->par->extract("casedata", "Ri", Ri);

  //send parameter to device
  kernelInfo["defines/p_T_cold"] = T_cold;
  kernelInfo["defines/p_T_hot"] = T_hot;
  kernelInfo["defines/p_Ri"] = Ri;
  
  buoyancyKernel = oudfBuildKernel(kernelInfo, "buoyancy");
}


void UDF_Setup(nrs_t *nrs)
{
  auto mesh = nrs->meshV;
    
  //set initial conditions
  int n_gll_points = mesh->Np * mesh->Nelements;
  for (int n = 0; n < n_gll_points; ++n)
  {
    nrs->U[n + 0 * nrs->fieldOffset] = 0; // x-velocity
    nrs->U[n + 1 * nrs->fieldOffset] = 0; // y-velocity
    nrs->U[n + 2 * nrs->fieldOffset] = 0; // z-velocity

    nrs->P[n] = 0.0; // pressure

    nrs->cds->S[n + 0 * nrs->fieldOffset] = T_cold; // temperature
  }
  
  //function pointer to add buyoancy term
  udf.uEqnSource = &custom_source;
}

void UDF_ExecuteStep(nrs_t *nrs, double time, int tstep)
{
}
